import java.util.LinkedHashMap;
import java.util.Map;




       /*        Этот код -- один сплошной костыль.
        *        Мне за него стыдно, честно
        *        Буду рад услышать любые пожелания и поправки.
        *
        *       Теперь об алгоритме :
        *
        *       Итак, если у нас имеется банкомат, в котором лежат деньги,
        *       то эти деньги нужно где-то хранить (в какой-либо структуре данных)
        *       Я выбрал LinkedHashMap т.к.:
        *           -он сохраняет порядок вставки элементов
        *           -add() и contains() за О(1)
        *       Деньги хранятся в LinkedHashMap'e в таком формате :
        *       ключ -- номинал купюры
        *       значение -- кол-во купюр данного номинала
        *
        *       Какой вообще алгоритм?
        *       банкомат должен реализовать следующие методы:
        *           put()
        *           dump()
        *           state()
        *           get()
        *           quit()
        *
        *       Для метода put(int d, int count) все ясно : мы просто кладем
        *      в банкомат count купюр номинала d
        *
        *      Для метода dump() тоже : мы пробегаемся по всем элементам LinkedHashMap'a,
        *      выводя кол-во купюр каждого номинала
        *
        *      метод state() находит сумму всех элементов, также проходясь по LinkedHashMap'у
        *
        *      Как работает метод get(amount) :
        *
        *      Для начала мы инициализиуем наш LinkedHashMap (далее stash),
        *      наполняя его ключами (номиналами) (5000, 1000, 500, 100, 50, 25, 10, 5, 3, 1)
        *      изначально банкомат пуст => value каждого элемента stash'a изначально равен 0
        *
        *      Теперь представим :
        *      мы кладем в банкомат две купюры по 50р, 1 купюру по 25р, 1 купюру по 10р
        *      Итого у нас в банкомате 135р
        *      теперь мы хотим обналичить эти 135р, для этого вызываем метод get(135);
        *
        *      Нащ stash имеет следующий вид :
        *      [ (5000, 0), (1000, 0), (500, 0), (100, 0), (50, 2), (25, 1), (10, 1), (5, 0), (3, 0), (1, 0) ]
        *      Чтобы получить 135 рублей, нам нужно найти купюры, которыми можно их выдать.
        *      Для этого я не придумал ничего другого, кроме как пробегаться по ключам (номиналам) stash'a до тех пор,
        *      пока мы не встретим ключ, который будет будет меньше, чем amount.
        *      В данном случае этим ключом будет 50. Когда мы встретили 50, мы уменьшаем amount на 50,
        *      (т.е. сумма, которую мы должны выдать уже уменьшена на 50), уменьшаем value элемента с
        *      ключом 50 на 1 и заново выполняем метод get от нового amount -- 135-50 = 85.
        *
        *      Так мы делаем до тех пор, пока amount не будет равен 0.
        *
        *      Но что делать, если, например, нащ stash будет иметь следущий вид :
        *      [ (5000, 0), (1000, 0), (500, 0), (100, 3), (50, 0), (25, 0), (10, 0), (5, 0), (3, 100), (1, 0) ]
        *
        *       Т.е. две банкноты по 100 и 100 банкнот по 3
        *       И мы хотим вызвать get(300)
        *
        *       Код будет пробегаться по элементам stash'a, пока не встретит ключ, меньший, чем amount
        *       Этим ключом будет 100. Тогда код выдаст две купюры по 100, а остаток будет пытаться выдать купюрами
        *       по 3, но сделать этого не сможет.
        *
        *       Так вот, чтобы избежать этого, есть метод checkForNominal(), который проверяет :
        *       можно ли выдать весь amount купюрами одного номинала.
        *       С этим методом программа сразу выдаст ответ "3=100", т.е.
        *       отдаст нам 100 купюр по 3 у.е.
        *
        *
        */



    /*
        НЕБОЛЬШОЕ ПРИМЕЧАНИЕ
        пока не исправил,
             иногда после вызова метода get(amount)
             в консоль выводятся две строки : одна абсолютно правильная,
             а вторая является результатом побочного вычисления функции, и вывод
             второй строки выглядит примерно так :
             %_value_%=0, всего 0 (либо любое число, являющееся результатом ф-ции
     */





public class AtmControlPanel implements IAtm {

    InputListener inputListener;
    AtmGetter atmGetter;
    static  Map<Integer, Integer> stash = new LinkedHashMap<>();


    /* создаем экземпляр класса, который принимает текст с клавиатуры */
    @Override
    public void getUserInput() {
        inputListener = new InputListener();
        inputListener.getInput();
    }

    /* реализуем get() */
    @Override
    public void get(int amount) {
        atmGetter = new AtmGetter();
        atmGetter.get(amount);
    }


    /*
    *
    *  реализуем метод put() :
    *  если уже имеется элемент с ключом, который мы кладем в LinkedHashMap,
    *  то этот элемент заменит старый элемент с тем же ключом, а метод put
    *  должен увеличивать число банкнот номинала d на count единиц,
    *
    *  поэтому мы заменяем элемент с ключом d на элемент с тем же ключом, но с
    *  count = кол-во предыдущих банкнот + кол-во банкнот, которые мы кладем в банкомат методом put
    *
    *
     */

    @Override
    public void put(int d, int count) {
        stash.put(d, stash.get(d) + count);
    }


    /* пробегаемся по LinkedHashMap'у, находя сумму элементов (номинал * кол-во) */
    @Override
    public int state() {
        int sum = 0;
        for (Map.Entry<Integer, Integer> stashEntry : stash.entrySet()) {
            sum += stashEntry.getKey() * stashEntry.getValue();
        }
        return sum;
    }

    /* выводим на консоль элементы stash'a, если они не равны 0 */

    @Override
    public void dump() {

        if (state() == 0) System.out.println("empty"); else {

            for (Map.Entry<Integer, Integer> stashEntry : stash.entrySet()) {
                if (stashEntry.getValue() != 0)
                    System.out.println(stashEntry.getKey() + "=" + stashEntry.getValue());
            }
        }

    }

    @Override
    public void exit() {
        System.out.print("EXIT");
        System.exit(-1);
    }

    /* заполняем stash */

    public void init(Map<Integer, Integer> stash) {
        stash.put(5000, 0);
        stash.put(1000, 0);
        stash.put(500, 0);
        stash.put(100, 0);
        stash.put(50, 0);
        stash.put(25, 0);
        stash.put(10, 0);
        stash.put(5, 0);
        stash.put(3, 0);
        stash.put(1, 0);
    }

}
